#!/usr/bin/env python

import os

Import(['env', 'commonpath'])

#---------------
# Bootloader-specific project options
#---------------
outputname = 'pjc-bootloader'      # output file name (withut extensions)
imagename  = 'pjc-flash-image'     # name of file to read flash into (no extension)

icspdevice = 'usbtiny'             # name of programming device for avrdude 

# fuses and lock bits
# be sure your settings are correct before changing these (search online for "AVR fuse calculator")
# note that avrdude reads unused bits back as 0
lfuse = '0xF7'           # external full-swing crystal and longest startup time
hfuse = '0xD8'           # defaults except use boot reset vector
efuse = '0x04'           # brown-out detection enabled at 4.3V
lockbits = '0x3F'        # defaults

# source files to build
commonfiles = ['uart.c', 'sharedmem.c', 'watchdog.c', 'cmd.c']
allfiles = Glob('*.c') + [commonpath + s for s in commonfiles]

# linker script (leave empty to use the default script chosen by avr-libc)
ldscript = 'bootloader' + os.sep + 'pjcbootloader.x'


#---------------
# End of bootloader options
#---------------



# full file names ("something.hex")
outputfile = outputname + env['HEXSUFFIX']
imagefile  = imagename + env['HEXSUFFIX']

# Generate file paths needed for below
ourdir  = env.Dir('.').path        # where we are now relative to top SConstruct file
elffile = ourdir + os.sep + outputname + env['PROGSUFFIX']
hexfile = ourdir + os.sep + outputfile

# an action to create the hex file using objcopy
boothex_act = Action(env['OBJCOPY'] + ' -O ihex -R .eeprom \"' + elffile  + '\" \"' + hexfile + '\"')

# a string forming a base avrdude command that we can just add on to in the targets
avrdude_base = 'avrdude -p ' + env['MCU'] + ' -c ' + icspdevice


# Create a clone of the base environment we can set up just for the bootloader
bootenv = env.Clone()


# target to build the bootloader
# paths and files in these commands are relative to the directory of this script
bb = bootenv.Program(outputname, allfiles)
bootenv.Alias('build-bootloader', bb)
bootenv.AddPostAction(bb, boothex_act)
bootenv.Clean(bb, outputfile)

if ldscript != '':
    bootenv.Append(LINKFLAGS = ['-T' + ldscript])
    bootenv.Depends(bb, '#'+ldscript)

# Note to self:  env.Command(target, [sources], cmd_string)
# We can pass in a dummy file for 'target' if the command doesn't generate an output
# We can also pass in an empty list "[]" if the command doesn't accept input files

# target to write the bootloader to the AVR using avrdude
wb = bootenv.Command('wb.dummy', outputfile, avrdude_base + ' -U flash:w:\"$SOURCE\":i')
wba = bootenv.Alias('write-bootloader', wb)
bootenv.AlwaysBuild(wb)

# target to read the AVR's flash memory into an output hex file
rf = bootenv.Command(imagefile, [], avrdude_base + ' -U flash:r:\"$TARGET\":i')
rfa = bootenv.Alias('read-flash', rf)
bootenv.AlwaysBuild(rf)

# target to erase everything--flash, EEPROM, and lock bits (but not fuse bits)
ed = bootenv.Command('ed.dummy', [], avrdude_base + ' -e')
eda = bootenv.Alias('erase-device', ed)
bootenv.AlwaysBuild(ed)

# target to write the AVR fuses and lock bits
wu = bootenv.Command('wu.dummy', [], avrdude_base + ' -U lfuse:w:' + lfuse + ':m -U hfuse:w:' + hfuse + 
                    ':m -U efuse:w:' + efuse + ':m -U lock:w:' + lockbits + ':m')
wua = bootenv.Alias('write-fuses', wu)
bootenv.AlwaysBuild(wu)
